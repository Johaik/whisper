---
- name: Deploy to Windows via Docker Desktop
  hosts: windows
  gather_facts: no

  vars_files:
    - group_vars/all.yml

  tasks:
    # ===========================================
    # Setup
    # ===========================================
    - name: Ensure app directory exists
      ansible.windows.win_file:
        path: "{{ win_app_dir }}"
        state: directory

    - name: Create volume directories
      ansible.windows.win_file:
        path: "{{ item }}"
        state: directory
      loop:
        - "{{ win_app_dir }}\\Calls"
        - "{{ win_app_dir }}\\outputs"
        - "{{ win_app_dir }}\\postgres-data"
        - "{{ win_app_dir }}\\redis-data"

    # ===========================================
    # OpenSSH Server (for remote monitoring access)
    # ===========================================
    - name: Install OpenSSH Server Windows capability
      ansible.windows.win_powershell:
        script: |
          # Check if OpenSSH Server is already installed
          $sshCapability = Get-WindowsCapability -Online | Where-Object Name -like 'OpenSSH.Server*'
          
          if ($sshCapability.State -eq 'Installed') {
            Write-Output "OpenSSH Server is already installed"
          } else {
            Write-Output "Installing OpenSSH Server..."
            Add-WindowsCapability -Online -Name OpenSSH.Server~~~~0.0.1.0
            Write-Output "OpenSSH Server installed successfully"
          }

    - name: Configure and start OpenSSH Server service
      ansible.windows.win_powershell:
        script: |
          # Set sshd service to start automatically
          Set-Service -Name sshd -StartupType Automatic
          
          # Start the service if not running
          $service = Get-Service -Name sshd
          if ($service.Status -ne 'Running') {
            Start-Service sshd
            Write-Output "OpenSSH Server started"
          } else {
            Write-Output "OpenSSH Server is already running"
          }
          
          # Set default shell to PowerShell (optional but recommended)
          New-ItemProperty -Path "HKLM:\SOFTWARE\OpenSSH" -Name DefaultShell `
            -Value "C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe" `
            -PropertyType String -Force | Out-Null
          
          Write-Output "OpenSSH Server configured with PowerShell as default shell"

    - name: Open firewall port for SSH (port 22)
      ansible.windows.win_powershell:
        script: |
          # Check if rule already exists
          $existingRule = Get-NetFirewallRule -Name "OpenSSH-Server-In-TCP" -ErrorAction SilentlyContinue
          
          if ($existingRule) {
            Write-Output "SSH firewall rule already exists"
          } else {
            # Create firewall rule for SSH
            New-NetFirewallRule -Name "OpenSSH-Server-In-TCP" `
              -DisplayName "OpenSSH Server (sshd) - Remote Monitoring" `
              -Description "Allow inbound SSH for remote monitoring access" `
              -Enabled True `
              -Direction Inbound `
              -Protocol TCP `
              -Action Allow `
              -LocalPort 22
            
            Write-Output "Firewall rule created for SSH (port 22)"
          }

    # ===========================================
    # Windows Exporter (Host Metrics)
    # ===========================================
    - name: Install Windows Exporter for host metrics
      ansible.windows.win_powershell:
        script: |
          $exporterPath = "C:\Program Files\windows_exporter"
          $serviceName = "windows_exporter"
          $version = "0.25.1"
          $downloadUrl = "https://github.com/prometheus-community/windows_exporter/releases/download/v$version/windows_exporter-$version-amd64.exe"
          
          # Check if already installed
          $service = Get-Service -Name $serviceName -ErrorAction SilentlyContinue
          if ($service) {
            Write-Output "Windows Exporter already installed"
            return
          }
          
          Write-Output "Installing Windows Exporter v$version..."
          
          # Create directory
          New-Item -ItemType Directory -Path $exporterPath -Force | Out-Null
          
          # Download
          $exePath = "$exporterPath\windows_exporter.exe"
          [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
          Invoke-WebRequest -Uri $downloadUrl -OutFile $exePath -UseBasicParsing
          
          # Install as service
          $collectors = "cpu,cs,logical_disk,memory,net,os,process,system,thermalzone"
          New-Service -Name $serviceName `
            -BinaryPathName "`"$exePath`" --collectors.enabled=$collectors --web.listen-address=127.0.0.1:9182" `
            -DisplayName "Prometheus Windows Exporter" `
            -Description "Exports Windows host metrics for Prometheus" `
            -StartupType Automatic | Out-Null
          
          # Start service
          Start-Service -Name $serviceName
          
          Write-Output "Windows Exporter installed and started on port 9182"

    # ===========================================
    # Registry Login
    # ===========================================
    # Write credentials directly to config.json (WinRM can't use credential store)
    - name: Configure Docker registry credentials
      ansible.windows.win_powershell:
        script: |
          $configDir = "$env:USERPROFILE\.docker"
          $configFile = "$configDir\config.json"
          
          # Create .docker directory if it doesn't exist
          if (-not (Test-Path $configDir)) {
            New-Item -ItemType Directory -Path $configDir -Force | Out-Null
          }
          
          # Read existing config or create empty one
          if (Test-Path $configFile) {
            try {
              $config = Get-Content $configFile -Raw | ConvertFrom-Json -AsHashtable
            } catch {
              $config = @{}
            }
          } else {
            $config = @{}
          }
          
          # Remove credsStore to disable credential helper
          if ($config.ContainsKey('credsStore')) {
            $config.Remove('credsStore')
          }
          
          # Add auths for ghcr.io with base64 encoded credentials
          $user = "{{ ghcr_username }}"
          $token = "{{ ghcr_token }}"
          $auth = [Convert]::ToBase64String([Text.Encoding]::UTF8.GetBytes("${user}:${token}"))
          
          if (-not $config.ContainsKey('auths')) {
            $config['auths'] = @{}
          }
          $config['auths']['ghcr.io'] = @{ 'auth' = $auth }
          
          # Write config without BOM
          $json = $config | ConvertTo-Json -Depth 10
          [System.IO.File]::WriteAllText($configFile, $json)
          Write-Output "Docker credentials configured for ghcr.io"
      no_log: true

    # ===========================================
    # Deploy Configuration
    # ===========================================
    - name: Copy docker-compose.yml
      ansible.windows.win_copy:
        src: "{{ playbook_dir }}/../docker-compose.yml"
        dest: "{{ win_app_dir }}\\docker-compose.yml"

    - name: Secure ports - bind to localhost only (not exposed to network)
      ansible.windows.win_powershell:
        script: |
          $file = "{{ win_app_dir }}\docker-compose.yml"
          $content = Get-Content $file -Raw
          # Bind all exposed ports to localhost only
          $content = $content -replace '"(\d+):(\d+)"', '"127.0.0.1:$1:$2"'
          Set-Content $file -Value $content -NoNewline
          Write-Output "Ports secured - bound to localhost only"

    - name: Create docker-compose.override.yml for Windows paths
      ansible.windows.win_copy:
        content: |
          # Windows-specific overrides for persistent storage
          services:
            postgres:
              volumes:
                - {{ win_app_dir }}\postgres-data:/var/lib/postgresql/data
            
            redis:
              volumes:
                - {{ win_app_dir }}\redis-data:/data
            
            api:
              volumes:
                - {{ win_app_dir }}\Calls:/data/calls:ro
                - {{ win_app_dir }}\outputs:/data/outputs
            
            worker:
              volumes:
                - {{ win_app_dir }}\Calls:/data/calls:ro
                - {{ win_app_dir }}\outputs:/data/outputs
                - whisper_model_cache:/home/whisper/.cache
            
            watcher:
              volumes:
                - {{ win_app_dir }}\Calls:/data/calls:ro
          
          volumes:
            whisper_model_cache:
        dest: "{{ win_app_dir }}\\docker-compose.override.yml"

    - name: Create batch-copy.ps1 script for chunked file processing
      ansible.windows.win_copy:
        content: |
          # Batch Copy Script - Syncs with Celery queue status
          # Only copies files when the processing queue can accept more
          
          param(
            [int]$BatchSize = 20,
            [string]$Source = "H:\My Drive\calls",
            [string]$Dest = "{{ win_app_dir }}\Calls",
            [string]$CopiedLog = "{{ win_app_dir }}\copied-files.txt",
            [string]$ApiUrl = "http://localhost:8000",
            [switch]$Silent = $false,
            [switch]$Force = $false
          )
          
          function Log($msg, $color = "White") {
            $timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
            if (-not $Silent) { Write-Host "[$timestamp] $msg" -ForegroundColor $color }
          }
          
          Log "=== Batch Copy Script ===" Cyan
          
          # Check if API is available and queue can accept more
          if (-not $Force) {
            try {
              $queueUrl = "$ApiUrl/api/v1/queue/status?threshold=$BatchSize"
              $response = Invoke-RestMethod -Uri $queueUrl -Method Get -TimeoutSec 5
              
              Log "Queue status: queued=$($response.queued), processing=$($response.processing), active=$($response.active_tasks)"
              
              if (-not $response.can_accept_more) {
                Log "Queue is busy ($($response.queued + $response.processing) pending, threshold: $($response.threshold)). Waiting..." Yellow
                exit 0
              }
              
              # Calculate how many we can add
              $currentLoad = $response.queued + $response.processing
              $canAdd = [Math]::Max(0, $BatchSize - $currentLoad)
              
              if ($canAdd -eq 0) {
                Log "Queue at capacity. Waiting..." Yellow
                exit 0
              }
              
              $BatchSize = $canAdd
              Log "Queue can accept $canAdd more files" Green
              
            } catch {
              Log "Could not reach API at $ApiUrl - is the service running?" Yellow
              Log "Error: $_" Yellow
              exit 1
            }
          }
          
          # Check source exists
          if (-not (Test-Path $Source)) {
            Log "Source folder not found: $Source - Google Drive may not be mounted" Yellow
            exit 0
          }
          
          # Get all audio files from source (oldest first for chronological processing)
          $allFiles = Get-ChildItem $Source -File -Include "*.mp3","*.wav","*.m4a","*.ogg","*.flac","*.aac" -Recurse | 
                      Sort-Object LastWriteTime
          
          Log "Total files in source: $($allFiles.Count)"
          
          # Load already copied files (by filename)
          $copied = @{}
          if (Test-Path $CopiedLog) {
            # Use -Unique to handle any existing bloat while loading
            Get-Content $CopiedLog | Select-Object -Unique | ForEach-Object { $copied[$_] = $true }
          }
          Log "Already copied (unique): $($copied.Count)"
          
          # Find files not yet copied
          $pending = $allFiles | Where-Object { -not $copied.ContainsKey($_.Name) }
          Log "Pending in source: $($pending.Count)"
          
          if ($pending.Count -eq 0) {
            Log "All files from source have been copied!" Green
            exit 0
          }
          
          # Copy next batch
          $batch = $pending | Select-Object -First $BatchSize
          Log "Copying $($batch.Count) files..." Yellow
          
          $copiedCount = 0
          foreach ($file in $batch) {
            try {
              if (-not $copied.ContainsKey($file.Name)) {
                Copy-Item $file.FullName -Destination $Dest -Force
                Add-Content $CopiedLog $file.Name
                $copied[$file.Name] = $true
                $copiedCount++
                Log "  [$copiedCount/$($batch.Count)] $($file.Name)"
              }
            } catch {
              Log "  ERROR copying $($file.Name): $_" Red
            }
          }
          
          Log ""
          Log "Batch complete: $copiedCount files copied" Green
          Log "Remaining in source: $($pending.Count - $copiedCount) files"
        dest: "{{ win_app_dir }}\\batch-copy.ps1"

    - name: Create scheduled task for auto-sync from Google Drive
      ansible.windows.win_powershell:
        script: |
          $taskName = "WhisperBatchSync"
          $scriptPath = "{{ win_app_dir }}\batch-copy.ps1"
          
          # Remove existing task if any
          Unregister-ScheduledTask -TaskName $taskName -Confirm:$false -ErrorAction SilentlyContinue
          
          # Create action to run PowerShell script silently
          $action = New-ScheduledTaskAction -Execute "powershell.exe" `
            -Argument "-NoProfile -ExecutionPolicy Bypass -WindowStyle Hidden -File `"$scriptPath`" -Silent"
          
          # Run every 2 minutes
          $trigger = New-ScheduledTaskTrigger -Once -At (Get-Date) -RepetitionInterval (New-TimeSpan -Minutes 2)
          
          # Run as current user
          $principal = New-ScheduledTaskPrincipal -UserId $env:USERNAME -LogonType S4U -RunLevel Limited
          
          # Create settings
          $settings = New-ScheduledTaskSettingsSet -AllowStartIfOnBatteries -DontStopIfGoingOnBatteries -StartWhenAvailable
          
          # Create and register task
          $task = New-ScheduledTask -Action $action -Trigger $trigger -Principal $principal -Settings $settings
          Register-ScheduledTask -TaskName $taskName -InputObject $task
          
          Write-Output "Scheduled task '$taskName' created - runs every 2 minutes"
          Write-Output "The task checks Celery queue status before copying files"

    - name: Create .env file for configuration
      ansible.windows.win_copy:
        content: |
          # Environment variables for whisper deployment
          API_TOKEN=dev-token-change-me
          MODEL_NAME=ivrit-ai/whisper-large-v3-turbo-ct2
          
          # Diarization (speaker detection)
          # Requires HuggingFace token with access to pyannote models
          # Get token at: https://huggingface.co/settings/tokens
          # Accept model terms at: https://huggingface.co/pyannote/speaker-diarization-3.1
          DIARIZATION_ENABLED={{ diarization_enabled | default('false') }}
          HUGGINGFACE_TOKEN={{ huggingface_token | default('') }}
          
          # Google Contacts API (for caller name lookup)
          # Setup: https://console.cloud.google.com/apis/credentials
          GOOGLE_CLIENT_ID={{ google_client_id | default('') }}
          GOOGLE_CLIENT_SECRET={{ google_client_secret | default('') }}
          GOOGLE_REFRESH_TOKEN={{ google_refresh_token | default('') }}
        dest: "{{ win_app_dir }}\\.env"

    # ===========================================
    # Pull and Start
    # ===========================================
    - name: Pull latest images
      ansible.windows.win_powershell:
        script: |
          cd "{{ win_app_dir }}"
          docker compose pull
          if ($LASTEXITCODE -ne 0) {
            throw "Failed to pull images"
          }
          Write-Output "Images pulled successfully"

    - name: Stop existing containers
      ansible.windows.win_powershell:
        script: |
          cd "{{ win_app_dir }}"
          docker compose down --remove-orphans 2>$null
          Write-Output "Stopped existing containers"
      ignore_errors: true

    - name: Start services
      ansible.windows.win_powershell:
        script: |
          cd "{{ win_app_dir }}"
          docker compose up -d
          if ($LASTEXITCODE -ne 0) {
            throw "Failed to start services"
          }

    - name: Wait for services to be healthy
      ansible.windows.win_powershell:
        script: |
          Start-Sleep -Seconds 10
          cd "{{ win_app_dir }}"
          docker compose ps

    - name: Run database migrations
      ansible.windows.win_powershell:
        script: |
          cd "{{ win_app_dir }}"
          docker compose run --rm migrate
          if ($LASTEXITCODE -ne 0) {
            throw "Migrations failed"
          }
          Write-Output "Migrations completed"

    - name: Show deployment status
      ansible.windows.win_powershell:
        script: |
          Write-Output "=== Container Status ==="
          docker ps --format "table {% raw %}{{.Names}}\t{{.Status}}\t{{.Ports}}{% endraw %}"
          Write-Output ""
          Write-Output "=== Deployment Complete ==="
          Write-Output "API available at: http://localhost:8000"
          Write-Output "Adminer at: http://localhost:8080 (if tools profile enabled)"
          Write-Output ""
          Write-Output "=== Monitoring Endpoints (via SSH tunnel) ==="
          Write-Output "Flower (Celery UI): http://localhost:5555"
          Write-Output "API Metrics: http://localhost:8000/metrics"
          Write-Output "Postgres Exporter: http://localhost:9187/metrics"
          Write-Output "Redis Exporter: http://localhost:9121/metrics"
          Write-Output ""
          Write-Output "SSH tunnel command from Mac:"
          Write-Output "  ssh -L 8000:localhost:8000 -L 5555:localhost:5555 -L 9187:localhost:9187 -L 9121:localhost:9121 user@this-server -N"
      register: status

    - name: Display status
      ansible.builtin.debug:
        msg: "{{ status.output }}"
